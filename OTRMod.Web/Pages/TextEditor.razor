@page "/text-editor"
@using BlazorDownloadFile
@using OTRMod.Web.Shared.Components
@using OTRMod.Web.Services.Archive
@using OTRMod.OTR
@using OTRMod.Utility
@using OTRMod.Web.Services
@using Microsoft.JSInterop
@implements IAsyncDisposable

<PageTitle>@T["txt_editor_title"]</PageTitle>
<h3>@T["txt_editor_h3"]</h3>
@T["txt_editor_desc"]
<br />
<br />

@if (_loadingFromArchive)
{
	<div class="alert alert-info">
		<div class="spinner-border spinner-border-sm me-2" role="status"></div>
		@T["loading_from_archive"]
	</div>
}
else if (!string.IsNullOrEmpty(_archiveLoadError))
{
	<div class="alert alert-warning">
		<i class="fa-solid fa-exclamation-triangle me-2"></i>
		@_archiveLoadError
		<a href="archive-browser" class="alert-link ms-2">@T["archive_browser_h3"]</a>
	</div>
}

<Accordion Id="selectionAccordion">
	<AccordionItem Header="@T["load_from_mod"]" Id="loadMod" IsInitiallyOpen=true>
		<InputFile class="form-control" type="file" id="modFile" OnChange="@((InputFileChangeEventArgs e) => ProcessInput(e, true))" accept=".otr,.o2r" single />
	</AccordionItem>
	<AccordionItem Header="@T["load_from_h"]" Id="loadH">
		<InputFile class="form-control" type="file" id="zretTextFile" OnChange="@((InputFileChangeEventArgs e) => ProcessInput(e, false))" accept=".h" single />
	</AccordionItem>
</Accordion>
<br />
<div class="row g-3" visi>
	<div class="col-sm-3" style="width: 190px;">
		<label for="charMap" class="form-label">@T["replacements"]</label>
		<InputTextArea class="form-control" id="charMap" rows="14" cols="16" @bind-Value="@charReplacements" @oninput="LoadTextArray" disabled="@_working"></InputTextArea>
	</div>
	<div class="col">
		<label for="tabMessageFiles" class="form-label">@T["txt_editor"]</label>
		<Tabs CssClass="border-0" TabList="@tabList" Id="tabMessageFiles" />
		@if (tabList.Count != _textFiles.Count + 1)
		{
			tabList.Clear();
			foreach (KeyValuePair<string, OTRMod.Z.Text> msg in _textFiles)
				tabList.Add(new TextDataItem { Id = msg.Key, Title = msg.Key, Content =@<p>@T["loading"]</p>, OnSelected = EventCallback.Factory.Create(this, (Tabs.TabItem e) => OnTabSelected(e)) });
			// Add "+" tab for creating new messages
			tabList.Add(new TextDataItem { Id = "__add__", Title = "+", Content =@<p></p>, OnSelected = EventCallback.Factory.Create(this, (Tabs.TabItem e) => OnAddTabSelected(e)) });
		}
	</div>
</div>
<br />
<div class="mb-3">
	<div class="form-check form-switch">
		<input class="form-check-input" type="checkbox" id="overrideSwitch" checked="@_isOverride" @onchange="OnOverrideChanged" />
		<label class="form-check-label" for="overrideSwitch">
			<strong>Override Mode</strong> - Create override files instead of replacing base game files
		</label>
	</div>
</div>
<label for="msgPath" class="form-label">@T["out_msg_path_in_mod"]</label>
<input class="form-control" list="msgPaths" id="msgPath" value="@_msgPathInMod" @onchange="OnPathChanged" aria-describedby="validationMsgPath" required />
<div id="validationMsgPath" class="invalid-feedback">@T["out_msg_path_invalid"]</div>
<datalist id="msgPaths">
	<option value="@DEFAULT_MESSAGE_PATH">
	</option>
	<option value="text/ger_message_data_static">
	</option>
	<option value="text/fra_message_data_static">
	</option>
	<option value="text/staff_message_data_static">
	</option>
</datalist>
<br />
<div class="mb-3">
	<label for="outputFormat" class="form-label">@T["sel_format"]</label>
	<select class="form-select" id="outputFormat" @onchange="OnFormatChanged">
		<option value="O2R" selected="@(_outputFormat == OutputFormat.O2R)">O2R (.o2r)</option>
		<option value="OTR" selected="@(_outputFormat == OutputFormat.OTR)">OTR (.otr)</option>
	</select>
</div>
<button class="btn btn-primary" type="submit" @onclick="ExportToMod" disabled="@(currentTab == null || !currentTab.IsLoaded)">
	@T["btn_save_mod"]
</button>
<button class="btn btn-primary" type="submit" @onclick="GetH" disabled="@(currentTab == null || !currentTab.IsLoaded)">
	@T["btn_save_h"]
</button>
<br />
@code {
	public class TextDataItem : Tabs.TabItem {
		public bool IsLoaded { get; set; }
		public string PreContent { get; set; } = "";
	}

	[Inject] private IBlazorDownloadFileService DlFileService { get; set; } = null!;
	[Inject] private SettingsService SettingsService { get; set; } = null!;
	[Inject] private IArchiveExplorer ArchiveExplorer { get; set; } = null!;
	[Inject] private NavigationManager NavigationManager { get; set; } = null!;
	[Inject] private IMessagePathService PathService { get; set; } = null!;
	[Inject] private IModFileNameService FileNameService { get; set; } = null!;
	[Inject] private IJSRuntime JSRuntime { get; set; } = null!;

	[SupplyParameterFromQuery(Name = "archive-path")]
	public string? ArchivePath { get; set; }

	private MemoryStream _modMs = new();
	private List<TextDataItem> tabList = new List<TextDataItem> { };
	private Dictionary<string, OTRMod.Z.Text> _textFiles = new();
	private Dictionary<string, string> _textFilePaths = new(); // Maps filename to original mod path
	private Dictionary<string, string> _replacements = new();
	private bool _working = false;
	private bool _loadingFromArchive = false;
	private string? _archiveLoadError;
	private const string DEFAULT_MESSAGE_PATH = "text/nes_message_data_static";
	private string _msgPathInMod = DEFAULT_MESSAGE_PATH; // Directory path only (no filename)
	private string _standardPath = DEFAULT_MESSAGE_PATH; // Store the standard directory path separately
	private bool _isOverride = false;
	private string currentHContent = "";
	private bool _needReplacements = false;
	private TextDataItem? currentTab;
	private OutputFormat _outputFormat = OutputFormat.O2R;
	private bool _hasUnsavedChanges = false;
	private IDisposable? _locationChangingRegistration;
	private string charReplacements = DecodeBase64("XG49MDEK4oC+PTdGCsOAPTgwCsOuPTgxCsOCPTgyCsOEPTgzCsOHPTg0CsOIPTg1CsOJPTg2CsOKPTg3CsOLPTg4CsOPPTg5CsOUPThBCsOWPThCCsOZPThDCsObPThECsOcPThFCsOfPThGCsOgPTkwCsOhPTkxCsOiPTkyCsOkPTkzCsOnPTk0CsOoPTk1CsOpPTk2CsOqPTk3CsOrPTk4CsOvPTk5CsO0PTlBCsO2PTlCCsO5PTlDCsO7PTlECsO8PTlFCltBXT05RgpbQl09QTAKW0NdPUExCltMXT1BMgpbUl09QTMKW1pdPUE0CltDLVVwXT1BNQpbQy1Eb3duXT1BNgpbQy1MZWZ0XT1BNwpbQy1SaWdodF09QTgK4pa8PUE5CltDb250cm9sLVBhZF09QUEKW0QtUGFkXT1BQg==");

	RenderFragment LoadMsg() {
		return @<InputTextArea class="form-control" rows="12" cols="96" @bind-Value="@currentHContent" @bind-Value:after="OnContentChanged" disabled="@_working" style="border-radius: 0 var(--bs-border-radius) var(--bs-border-radius);"></InputTextArea>;
	}

	private void OnContentChanged() {
		_hasUnsavedChanges = true;
		UpdateUnsavedChangesFlag();
	}

	private void UpdateUnsavedChangesFlag() {
		_ = JSRuntime.InvokeVoidAsync("eval", $"window.__hasUnsavedChanges = {(_hasUnsavedChanges ? "true" : "false")};");
	}

	protected override async Task OnInitializedAsync() {
		_outputFormat = await SettingsService.GetOutputFormatAsync();
		SetReplacements();

		// Register Blazor navigation handler: when there are unsaved changes,
		// prevent SPA navigation and trigger a full-page navigation so the
		// browser "beforeunload" handler shows the native localized message.
		_locationChangingRegistration = NavigationManager.RegisterLocationChangingHandler(async context => {
			if (_hasUnsavedChanges) {
				// Stop the router from performing the navigation
				context.PreventNavigation();

				// Ensure the global beforeunload handler and helper exist, then force a real navigation
				await JSRuntime.InvokeVoidAsync("eval", @"
				if (!window.__textEditorBeforeUnloadAdded) {
					window.__textEditorBeforeUnloadAdded = true;
					window.addEventListener('beforeunload', function(e) {
						if (window.__hasUnsavedChanges) {
							e.preventDefault();
							e.returnValue = '';
							return '';
						}
					});
				}
				if (!window.blazorHelpers) { window.blazorHelpers = {}; }
				if (!window.blazorHelpers.navigateToWithUnload) {
					window.blazorHelpers.navigateToWithUnload = function(url) { window.location.href = url; };
				}
				");

				// Trigger full navigation (will invoke beforeunload and show native prompt)
				await JSRuntime.InvokeVoidAsync("blazorHelpers.navigateToWithUnload", context.TargetLocation);
			}
		});
	}

	public async ValueTask DisposeAsync() {
		_locationChangingRegistration?.Dispose();
		await JSRuntime.InvokeVoidAsync("eval", "window.__hasUnsavedChanges = false;");
	}

	protected override async Task OnParametersSetAsync() {
		_archiveLoadError = null;

		// Load from archive if path is provided and archive is loaded
		if (!string.IsNullOrEmpty(ArchivePath) && _textFiles.Count == 0) {
			Console.WriteLine($"[TextEditor] OnParametersSetAsync - ArchivePath: {ArchivePath}");
			Console.WriteLine($"[TextEditor] ArchiveExplorer.IsLoaded: {ArchiveExplorer.IsLoaded}");

			if (ArchiveExplorer.IsLoaded)
				await LoadFromArchiveAsync(ArchivePath);
			else {
				Console.WriteLine("[TextEditor] Archive not loaded - archive state was lost during navigation");
				_archiveLoadError = T["archive_not_loaded"];
			}
		}
	}

	private async void OnFormatChanged(ChangeEventArgs e) {
		if (Enum.TryParse<OutputFormat>(e.Value?.ToString(), out var format)) {
			_outputFormat = format;
			await SettingsService.SetOutputFormatAsync(format);
		}
	}

	private void OnTabSelected(Tabs.TabItem e) {
		if (currentTab != null)
			currentTab.PreContent = currentHContent;

		var tab = e as TextDataItem;
		if (tab == null)
			return;

		Console.WriteLine($"Tab selected: {tab.Id}");
		if (!tab.IsLoaded || _needReplacements) {
			tab.PreContent = _textFiles[tab.Id].ToHumanReadable(_replacements);
			_needReplacements = false;
			tab.IsLoaded = true;
		}

		currentHContent = tab.PreContent;

		// Use the original mod path if available, extract directory path (remove filename)
		string fullPath;
		if (_textFilePaths.TryGetValue(tab.Id, out var storedPath))
			fullPath = PathService.NormalizePath(storedPath);
		else
			fullPath = $"text/{tab.Title}/{tab.Title}";

		// Extract directory path (remove filename)
		var directoryPath = PathService.GetDirectoryPath(fullPath);
		if (string.IsNullOrEmpty(directoryPath))
			directoryPath = $"text/{tab.Title}"; // Fallback

		// Determine if it's an override path and set the switch accordingly
		_isOverride = PathService.IsOverridePath(directoryPath);

		// Store the standard directory path (without override prefix and without filename)
		_standardPath = PathService.IsOverridePath(directoryPath) 
			? PathService.GetDirectoryPath(PathService.ToStandardPath(directoryPath + "/dummy"))
			: directoryPath;

		// Update the displayed path based on override state
		UpdatePathFromOverrideState();

		tab.Content = LoadMsg();
		currentTab = tab;
	}

	private void OnAddTabSelected(Tabs.TabItem e) {
		// Create a new empty message file
		var newFileName = $"new_message_{DateTime.Now:yyyyMMddHHmmss}";
		var newText = new OTRMod.Z.Text(Array.Empty<byte>(), _replacements);

		_textFiles.Add(newFileName, newText);
		_textFilePaths.Add(newFileName, $"{_msgPathInMod}/{newFileName}");

		// Create a new tab
		var newTab = new TextDataItem { 
			Id = newFileName, 
			Title = newFileName, 
			Content = @<p>@T["loading"]</p>, 
			OnSelected = EventCallback.Factory.Create(this, (Tabs.TabItem t) => OnTabSelected(t)),
			IsLoaded = false,
			PreContent = ""
		};

		tabList.Insert(tabList.Count - 1, newTab); // Insert before the "+" tab
		StateHasChanged();

		// Select the new tab
		OnTabSelected(newTab);
		_hasUnsavedChanges = true;
		UpdateUnsavedChangesFlag();
	}

	private void OnOverrideChanged(ChangeEventArgs e) {
		if (bool.TryParse(e.Value?.ToString(), out var isOverride)) {
			_isOverride = isOverride;
			UpdatePathFromOverrideState();
		}
	}

	private void OnPathChanged(ChangeEventArgs e) {
		if (e.Value is string newPath && !string.IsNullOrWhiteSpace(newPath)) {
			var normalized = PathService.NormalizePath(newPath);
			// Extract directory path (remove filename if present)
			var directoryPath = PathService.GetDirectoryPath(normalized);
			if (string.IsNullOrEmpty(directoryPath))
				directoryPath = normalized; // User typed just a directory path

			// Update override state based on what user typed
			var isPathOverride = PathService.IsOverridePath(directoryPath);

			// If user typed an override path, update the override state
			if (isPathOverride) {
				_isOverride = true;
				_standardPath = PathService.GetDirectoryPath(PathService.ToStandardPath(directoryPath + "/dummy"));
				_msgPathInMod = directoryPath; // Keep what user typed (directory only)
			}
			// If user typed a standard path but override is checked, transform it
			else if (_isOverride) {
				_standardPath = directoryPath;
				_msgPathInMod = PathService.GetDirectoryPath(PathService.ToOverridePath(directoryPath + "/dummy"));
			}
			// User typed standard path and override is off
			else {
				_standardPath = directoryPath;
				_msgPathInMod = directoryPath;
			}
		}
	}

	private void UpdatePathFromOverrideState() {
		if (_isOverride) {
			// Only generate a new override path if current path is not already an override path
			// This preserves user's manually typed override paths
			if (!PathService.IsOverridePath(_msgPathInMod)) {
				var overridePath = PathService.ToOverridePath(_standardPath + "/dummy");
				_msgPathInMod = PathService.GetDirectoryPath(overridePath);
			}
			// If it's already an override path, keep it as-is (user may have typed a specific GUID)
		}
		else {
			// Convert override path back to standard if switching off override mode
			_msgPathInMod = _standardPath;
		}
	}

	private static string DecodeBase64(string base64String) {
		byte[] data = Convert.FromBase64String(base64String);
		return System.Text.Encoding.UTF8.GetString(data);
	}

	private void LoadTextArray(ChangeEventArgs e) {
		charReplacements = e.Value?.ToString() ?? "";
		SetReplacements();
	}

	private void SetReplacements() {
		var charMapTemp = OTRMod.ID.Text.LoadCharMap(charReplacements.ToStringArray());
		var diffKeys = charMapTemp.Where(kv => !_replacements.ContainsKey(kv.Key) || !_replacements[kv.Key].Equals(kv.Value)).ToDictionary(kv => kv.Key, kv => kv.Value);

		if (diffKeys.Any()) {
			_replacements = charMapTemp;
			_needReplacements = true;
			Console.WriteLine($"Replacements updated:");
			foreach (var kv in diffKeys)
				Console.WriteLine($"Key: {kv.Key}, Value: {kv.Value}");
		}
	}

	private async Task LoadFromArchiveAsync(string path) {
		_loadingFromArchive = true;
		StateHasChanged();

		try {
			Console.WriteLine($"[TextEditor] LoadFromArchiveAsync - path: {path}");
			tabList.Clear();
			_textFiles.Clear();
			_textFilePaths.Clear();

			var content = await ArchiveExplorer.GetContentAsync(path);
			Console.WriteLine($"[TextEditor] Content retrieved: {content != null} (length: {content?.Length ?? 0})");

			if (content != null)
			{
				var modRes = OTRMod.Z.Resource.Read(content);
				var modResText = OTRMod.Z.Text.LoadFrom(modRes);
				var modResFileName = Path.GetFileName(path);
				var normalizedPath = PathService.NormalizePath(path);
				var directoryPath = PathService.GetDirectoryPath(normalizedPath);

				_textFiles.Add(modResFileName, modResText);
				_textFilePaths.Add(modResFileName, normalizedPath);

				// Determine if it's an override path (check directory)
				_isOverride = PathService.IsOverridePath(directoryPath);
				_standardPath = PathService.IsOverridePath(directoryPath)
					? PathService.GetDirectoryPath(PathService.ToStandardPath(directoryPath + "/dummy"))
					: directoryPath;

				_msgPathInMod = directoryPath;
				Console.WriteLine($"[TextEditor] Text file loaded: {modResFileName}, Override: {_isOverride}");
			}
			else
			{
				Console.WriteLine("[TextEditor] Content was null");
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine($"[TextEditor] Error loading from archive: {ex.Message}");
			Console.WriteLine($"[TextEditor] Stack trace: {ex.StackTrace}");
		}
		finally
		{
			_loadingFromArchive = false;
			StateHasChanged();
		}
	}

	private async void ProcessInput(InputFileChangeEventArgs e, bool isModFile) {
		IBrowserFile inputFile = e.File;
		tabList.Clear();
		_textFiles.Clear();
		_textFilePaths.Clear();

		MemoryStream dataMs = new();
		if (isModFile) {
			await inputFile.OpenReadStream(0x4000000).CopyToAsync(dataMs); // is 64 MiB too much for your mod file?
			dataMs.Position = 0; // Reset position before reading
			Dictionary<string, Stream> msgResFiles = new();
			await Task.Delay(10);

			// Determine if it's O2R or OTR based on file extension
			bool isO2R = inputFile.Name.EndsWith(".o2r", StringComparison.OrdinalIgnoreCase);
			if (isO2R)
				Load.OnlyFromO2R("message_data_static", dataMs, ref msgResFiles);
			else
				Load.OnlyFrom("message_data_static", dataMs, ref msgResFiles);

			foreach (var msgRes in msgResFiles) {
				await Task.Delay(10);
				var modRes = OTRMod.Z.Resource.Read(((MemoryStream)msgRes.Value).ToArray());
				var modResText = OTRMod.Z.Text.LoadFrom(modRes);
				var modResFileName = Path.GetFileName(msgRes.Key);
				var modResFullPath = PathService.NormalizePath(msgRes.Key); // Preserve the original path from mod

				_textFiles.Add(modResFileName, modResText);
				_textFilePaths.Add(modResFileName, modResFullPath);
				msgRes.Value.Flush();
			}

			// If files were loaded, set override state and path from the first file
			if (_textFilePaths.Count > 0) {
				var firstPath = _textFilePaths.Values.First();
				var directoryPath = PathService.GetDirectoryPath(firstPath);
				_isOverride = PathService.IsOverridePath(directoryPath);
				_standardPath = PathService.IsOverridePath(directoryPath)
					? PathService.GetDirectoryPath(PathService.ToStandardPath(directoryPath + "/dummy"))
					: directoryPath;
				_msgPathInMod = directoryPath;
			}
		}
		else {
			await inputFile.OpenReadStream(0x100000).CopyToAsync(dataMs); // 1 MiB is more than enough for .h files
			var modResText = new OTRMod.Z.Text(dataMs.ToArray(), _replacements);
			var modResFileName = Path.GetFileNameWithoutExtension(inputFile.Name);

			_textFiles.Add(modResFileName, modResText);
		}

		StateHasChanged();

		dataMs.Flush();
	}

	private async Task GetH() {
		if (currentTab == null)
			return;

		_working = true;
		await Task.Delay(10);
		string hFileName = $"{currentTab.Title}.h";
		await DlFileService.DownloadFileFromText(hFileName, currentHContent, System.Text.Encoding.UTF8, "text/plain");
		_hasUnsavedChanges = false;
		UpdateUnsavedChangesFlag();
		_working = false;
	}

	private async Task ExportToMod() {
		if (currentTab == null)
			return;

		_working = true;
		_modMs.SetLength(0);
		var modResText = new OTRMod.Z.Text(currentHContent, _replacements);
		await Task.Delay(10);

		// Combine directory path with tab name (filename)
		var directoryPath = PathService.NormalizePath(_msgPathInMod);
		var fileName = currentTab.Title;
		var finalPath = $"{directoryPath}/{fileName}";

		Generate.AddFile(finalPath, modResText.Formatted());

		// Generate appropriate mod file name using the service
		var modFileName = FileNameService.GenerateFileName(finalPath, _outputFormat, _isOverride);

		if (_outputFormat == OutputFormat.O2R) {
			Generate.FromImageO2R(ref _modMs);
		} else {
			Generate.FromImage(ref _modMs);
		}

		await DlFileService.DownloadFile(modFileName, _modMs, "application/octet-stream");
		_hasUnsavedChanges = false;
		UpdateUnsavedChangesFlag();
		_working = false;
	}
}